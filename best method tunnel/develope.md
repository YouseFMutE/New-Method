# Tunnel Project Plan (Server/Client مشترک)

## هدف
ساخت یک ابزار تونل استاندارد و امن برای فوروارد کردن **یک پورت مشخص** از Server به Client.
ابزار باید:
- یک باینری واحد داشته باشد که هم نقش Server و هم Client را اجرا کند.
- CLI و منوی گرافیکی ترمینالی (TUI) داشته باشد.
- در اولین اجرا، به‌صورت مرحله‌ای نقش و تنظیمات را از کاربر بگیرد.
- داده‌ها را با اندازه‌های متنوع منتقل کند و با backpressure سازگار باشد.

## اصول و محدودیت‌ها
- تمرکز روی امنیت قابل‌اتکا (احراز هویت با کلید مشترک).
- هیچ هدفی برای پنهان‌سازی/دور زدن پایش شبکه تعریف نمی‌شود.
- فوروارد فقط برای **یک پورت** در هر اجرا.

## تصمیم‌های فنی (قطعی)
- زبان: Rust
- Async runtime: tokio
- امنیت ارتباط: PSK (بدون TLS، بدون رمزنگاری دیتا)
  - کلید مشترک (PSK) بین Server/Client
  - احراز هویت: PSK + HMAC (یک‌طرفه)
- پروتکل انتقال: TCPmux داخلی (frame-based)
  - چند stream روی یک اتصال TCP
  - سربار کم و مناسب برای کانکشن پایدار
  - امکان چند اتصال هم‌زمان تونل از سمت Client (`mux_con`)

## معماری
### Roles
- **Server**: روی ایران، دو پورت دارد:
  - `public_listen` برای دریافت ترافیک کاربران
  - `tunnel_listen` برای اتصال تونل از سمت Client
- **Client**: روی خارج، به `tunnel_listen` سرور متصل می‌شود و ترافیک را به مقصد محلی فوروارد می‌کند.

### Data Flow (تک پورت)
1. Server پورت عمومی را listen می‌کند.
2. Client به Server متصل می‌شود (PSK + HMAC، بدون رمزنگاری داده).
3. هر اتصال ورودی به Server در یک کانال منطقی به Client هدایت می‌شود.
4. Client اتصال را به مقصد نهایی (مثلاً 127.0.0.1:1414) باز می‌کند و داده را رله می‌کند.

## CLI / TUI
### CLI
```
mytunnel init
mytunnel run
```

### TUI (منوی گرافیکی ترمینالی)
- انتخاب نقش (Server / Client)
- دریافت مرحله‌ای اطلاعات:
  - آدرس/پورت‌های listen
  - آدرس/پورت مقصد
  - تعداد اتصال‌های هم‌زمان تونل (TCPmux)
  - کلید مشترک (PSK) - تولید رندوم یا ورود دستی
  - سیاست‌های اتصال (حداکثر اندازه فریم، نرخ تلاش مجدد)

## فایل‌ها
- `config.toml`
- `logs/`
- `data/` (اگر لازم باشد)

### فیلدهای کلیدی config
- `psk_hex`: کلید مشترک 32 بایت (64 کاراکتر hex)
- `max_frame_size`: حداکثر اندازه payload (بایت)
- `reconnect_delay_ms` / `reconnect_max_delay_ms`: کنترل retry

## لاگ و مانیتورینگ
- خروجی برنامه به فایل `/var/log/mytunnel/mytunnel.log` هدایت می‌شود (systemd).
- اسکریپت `scripts/monitor.sh` برای وضعیت سرویس و لاگ‌های اخیر.

## Milestones
1. طراحی پروتکل فریم‌بندی و message types
2. پیاده‌سازی roleها با TCP + PSK + multiplex داخلی
3. CLI + TUI اولیه
4. مدیریت کانکشن‌ها و backpressure
5. تست‌های یکپارچگی و Load test ساده
6. بسته‌بندی (static build + systemd unit)

## سوالات باز (نیاز به تایید شما)
- نیاز به NAT traversal نداریم؟

## پروتکل پیشنهادی (خلاصه)
- Handshake:
  - ClientHello: نسخه + nonce (24 بایت)
  - ServerHello: nonce (24 بایت) + HMAC(psk, client_nonce || server_nonce)
  - ClientAck: HMAC(psk, server_nonce || client_nonce)
- Data:
  - انتقال داده از طریق فریم‌های داخلی multiplex
  - داده‌ها **رمزنگاری نمی‌شوند**
